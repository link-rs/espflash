//! RAM target module.
//!
//! This module defines the traits and types used for flashing operations on a
//! target device's RAM.

use crate::{Error, image_format::Segment, target::MAX_RAM_BLOCK_SIZE};
use crate::{
    command::{Command, CommandType},
    connection::{Connection, SerialInterface},
};
use super::ProgressCallbacks;

/// Applications running in the target device's RAM.
#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]
pub struct RamTarget {
    entry: Option<u32>,
    block_size: usize,
}

impl RamTarget {
    /// Create a new RAM target.
    pub fn new(entry: Option<u32>, block_size: usize) -> Self {
        RamTarget { entry, block_size }
    }
}

impl Default for RamTarget {
    fn default() -> Self {
        Self::new(None, MAX_RAM_BLOCK_SIZE)
    }
}

impl RamTarget {
    /// Begin the flashing operation.
    pub async fn begin<P: SerialInterface>(&mut self, _connection: &mut Connection<P>) -> Result<(), Error> {
        Ok(())
    }

    /// Write a segment to the target device.
    pub async fn write_segment<P: SerialInterface>(
        &mut self,
        connection: &mut Connection<P>,
        segment: Segment<'_>,
        progress: &mut dyn ProgressCallbacks,
    ) -> Result<(), Error> {
        let addr = segment.addr;

        let padding = 4 - segment.data.len() % 4;
        let block_count = (segment.data.len() + padding).div_ceil(self.block_size);

        connection.command(Command::MemBegin {
            size: segment.data.len() as u32,
            blocks: block_count as u32,
            block_size: self.block_size as u32,
            offset: addr,
            supports_encryption: false,
        }).await?;

        let chunks = segment.data.chunks(self.block_size);
        let num_chunks = chunks.len();

        progress.init(addr, num_chunks);

        for (i, block) in chunks.enumerate() {
            connection.command(Command::MemData {
                sequence: i as u32,
                pad_to: 4,
                pad_byte: 0,
                data: block,
            }).await?;

            progress.update(i + 1)
        }

        progress.finish(false);

        Ok(())
    }

    /// Complete the flashing operation.
    pub async fn finish<P: SerialInterface>(&mut self, connection: &mut Connection<P>, reboot: bool) -> Result<(), Error> {
        if reboot {
            let entry = self.entry.unwrap_or_default();
            let old_timeout = connection.serial.timeout();
            connection.serial.set_timeout(CommandType::MemEnd.timeout())?;
            let result = connection.command(Command::MemEnd {
                no_entry: entry == 0,
                entry,
            }).await;
            connection.serial.set_timeout(old_timeout)?;
            result?;
        }

        Ok(())
    }
}
